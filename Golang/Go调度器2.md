## Go 任务调度 - Part II

### 序幕

​	这是一个系列文章中的第二篇，它将提供对Go调度程序背后的机制和语义的理解。这篇文章重点介绍Go调度程序。

### 介绍

​	在第一部分中，我解释了操作系统调度程序的各个方面，我认为这些方面对于理解和欣赏Go调度程序的语义很重要。在本文中，我将在语义级别上解释Go调度程序的工作方式，并着重于高级行为。Go调度程序是一个复杂的系统，少部分的机械细节并不重要。重要的是要有一个良好的模型来说明事物的工作方式和行为方式，这将使您做出更好的工程决策。

### 程序启动

​	当您的Go程序启动时，会为主机上标识的每个虚拟核提供一个逻辑处理器（P）。如果您的处理器每个物理核心具有多个硬件线程（超线程），则每个硬件线程将作为虚拟核心呈现给您的Go程序。为了更好地理解这一点，请查看我的MacBook Pro的系统报告。

![94_figure1](..\images\94_figure1.png)

​	您可以看到我有一个具有4个物理核心的处理器。该报告未公开的是我每个物理核心拥有的硬件线程数。英特尔酷睿i7处理器具有超线程功能，这意味着每个物理内核有2个硬件线程。这将向Go程序报告8个虚拟内核可用于并行执行OS线程。

要对此进行测试，请考虑以下程序：

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {

    // NumCPU returns the number of logical
    // CPUs usable by the current process.
    fmt.Println(runtime.NumCPU())
}
```

​	当我在本地计算机上运行该程序时，NumCPU（）函数调用的结果将为8。我在计算机上运行的任何Go程序都将显示8。

​	每个P都分配有一个OS线程（“ M”）。“ M”代表机器。OS线程仍然是由操作系统管理，操作系统仍然是负责将线程放到核心执行，这在最后一篇会提到。这意味着，当我在计算机上运行Go程序时，我有8个线程可以执行我的工作，每个线程都单独连接到P。

​	每个Go程序还会获得一个初始Goroutine（“ G”），这是Go程序的执行路径。Goroutine本质上是一个[协程](https://en.wikipedia.org/wiki/Coroutine)（Coroutine），但这就是Go，因此我们将字母“ C”替换为“ G”，然后得到单词Goroutine。您可以将Goroutines视为应用程序级线程，并且它们在许多方面类似于OS线程。就像OS线程在内核中进行上下文切换一样，Goroutine在M时进行上下文切换也是如此。

​	最后一个难题是运行队列。Go调度程序中有两个不同的运行队列：全局运行队列（GRQ）和本地运行队列（LRQ）。每个P都有一个LRQ，LRQ管理分配给在P上下文中执行的Goroutine。这些Goroutine轮流在上下文中打开和关闭分配给该P的M。GRQ用于存放尚未分配给P的Goroutine。将Goroutines从GRQ转移到LRQ的过程，我们会在后面讨论。

图2提供了所有这些组件的图像。