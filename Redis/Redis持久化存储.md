## Redis持久化存储

#### 1.通过保存快照实现（RDB）

RDB主要实现是在满足条件的情况下Fork一个子进程将redis的快照存在一个临时文件中，完成后替换掉原先的快照文件。

![img](http://img1.tuicool.com/NjYjYvF.png!web?_=6182478)

配置如下：

```redis
＃将数据库保存在磁盘上：
＃
＃save <seconds> <changes>
＃
＃表示 如果在给定秒数之内，发生了给定的变化，则保存快照到磁盘
＃
＃在下面的示例中，行为将是保存：
＃在900秒（15分钟）后，如果至少更改了1个键
＃在300秒（5分钟）后，如果至少更改了10个键
＃在60秒后，如果至少更改了10000个键
＃
＃注意：您可以通过注释掉所有“保存”行来完全禁用保存。
save 900 1
save 300 10
save 60 10000
```

#### 2.通过追加到文件实现 AOF

![img](http://img2.tuicool.com/YrqaY3f.png!web?_=6182478)

redis将写和删除的操作通过文件追加的方式存储到记录文件之中。

```redis
＃fsync（）调用告诉操作系统实际在磁盘上写入数据
＃某些操作系统会真正刷新磁盘上的数据而不是等待输出缓冲区中的更多数据。 
＃其他一些操作系统将尝试尽快执行。
＃
＃Redis支持三种不同的模式：
＃
＃no：不要fsync，只要让OS在需要时刷新数据即可 -速度较快，最不安全。
＃always：每次写入都在日志里追加	-慢，最安全。
＃everysec：每秒仅同步一次 -两者中和。
＃
＃默认为“everysec”，因为通常是速度和数据安全两者结合。 
＃修改至“no”将使操作系统在以下情况时刷新输出缓冲区
＃它希望获得更好的性能（但如果您能够接受一些数据丢失会考虑默认的持久化模式（即快照）
＃或相反，请使用“always”，该速度非常慢，但比每秒钟安全一点。
# appendfsync always
appendfsync everysec
# appendfsync no
```



### 总结：

​	事实上，可以看出：RDB持久化其实并不是很靠谱，鉴于他是在server运行中去fork一个子进程来保存快照的，其**性能会更好**，但是在写入redis频繁的情况下，很难保证数据**一致性**。

​	AOF持久化操作不然，每一次操作都会记录，这意味着，我们可以完美复现所有操作来保证数据的一致性，但是对性能影响很大。

​	所以实际情况下，需要**两者结合**使用。

