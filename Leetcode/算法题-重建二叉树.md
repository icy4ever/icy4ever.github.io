## 重建二叉树

**输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。**

**例如，给出**

**前序遍历 preorder = [3,9,20,15,7]**
**中序遍历 inorder = [9,3,15,20,7]**
**返回如下的二叉树：**

    		3
       / \
      9  20
        /  \
       15   7
**来源：力扣（LeetCode）**
**链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof**
**著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder)==0 {
        return nil
    }
    var k int 
    for key,v:=range inorder {
        if preorder[0]==v {
            k=key
        }
    }
    root := &TreeNode{Val:preorder[0],Left:buildTree(preorder[1:1+k],inorder[:k]),Right:buildTree(preorder[k+1:],inorder[k+1:])}
    return root
}
//核心思想：中序遍历是先遍历左子树后遍历根节点，再遍历右子树。
//前序遍历是先遍历根节点，再遍历左子树和右子树
//其实对于遍历顺序我们可以这样记忆：中序遍历↗↘（中间点为核心）
//前序遍历↙→核心在左子树，后序遍历为→↖核心在右子树
```

