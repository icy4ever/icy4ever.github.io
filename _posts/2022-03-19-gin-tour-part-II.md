# Ginæ¢ç´¢ä¹‹æ—… Part-II å‰ç¼€æ ‘

```
æ¥ç€ä¸Šä¸€ç« è·¯ç”±è§£æï¼Œæœ¬ç« æˆ‘ä»¬ç»§ç»­çœ‹Ginçš„æ ¸å¿ƒæ¨¡å— - å‰ç¼€æ ‘çš„å®ç°ã€‚ç”±äºè¿™å—å‚æ‚ç€é€šé…ç¬¦ ':' å’Œ '*' ï¼Œæ‰€ä»¥æ•´ä½“çš„ä»£ç å¤æ‚åº¦ä¼šæ¯”è¾ƒé«˜ã€‚æ‰€ä»¥å‡å°‘æ•´ç¯‡çš„ä»£ç è§£æã€‚
```

## æ ‘çš„æ„é€ 

 Ginä¸æ˜¯æ•´ä½“ç”¨ä¸€é¢—æ ‘ï¼Œè€Œæ˜¯æ ¹æ®æ–¹æ³•æ¥ç”Ÿæˆä¸åŒçš„æ ‘ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š [![ginè·¯ç”±](https://user-images.githubusercontent.com/38686456/159127106-3efd1171-5bf0-40e8-be37-4c6efc983626.png)](https://user-images.githubusercontent.com/38686456/159127106-3efd1171-5bf0-40e8-be37-4c6efc983626.png)

 æ¯ä¸ªHttpè¯·æ±‚æ–¹æ³•éƒ½ä¼šç»´æŠ¤ä¸€é¢—æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚æ‰€ä»¥è¿™é‡Œè¯»è€…ä»¥ä¸ºGinæ„é€ è‡ªå·±çš„å‰ç¼€æ ‘æ—¶ï¼Œä¼šæ ¹æ® / æ¥åˆ†å‰²è·¯ç”±æ¥æ„é€ æ ‘ã€‚ä½†ç°å®æƒ…å†µæ˜¯Ginå¹¶ä¸ä¼šæŒ‰ç…§ / æ¥ç›´æ¥åˆ†å‰²ï¼Œè€Œæ˜¯é‡‡å–ä¸€ç§Lazy Loadçš„æ–¹å¼ï¼Œä¸¾ä¸ªğŸŒ°ï¼š

### æ’å…¥ 

å‡è®¾è¿™æ˜¯ä¸€é¢—ç©ºçš„æ ‘ï¼Œæˆ‘ä»¬åœ¨æ·»åŠ  /hello/worldæ—¶ä¼šäº§ç”Ÿå¦‚ä¸‹æƒ…å†µï¼š

[![ginè·¯ç”±åˆå§‹åŒ–](https://user-images.githubusercontent.com/38686456/159127126-c85d3ac0-05a7-4d1f-b15c-9082287e0227.png)](https://user-images.githubusercontent.com/38686456/159127126-c85d3ac0-05a7-4d1f-b15c-9082287e0227.png)

 ä½†æ˜¯ï¼Œå½“ä½ æ·»åŠ å¦ä¸€ä¸ªå…·æœ‰å…¬å…±å‰ç¼€/helloçš„æ—¶å€™æ‰ä¼šå°†è¯¥èŠ‚ç‚¹åšè¿›ä¸€æ­¥æ‹†åˆ†ï¼Œå½“æˆ‘ä»¬æ·»åŠ /hello/michaelæ—¶ï¼Œä¼šäº§ç”Ÿå¦‚ä¸‹æ•ˆæœï¼š

[![ginè·¯ç”±åˆå§‹åŒ– (1)](https://user-images.githubusercontent.com/38686456/159127134-01b1021d-de3d-4ce1-8ad0-ba731c5eecd0.png)](https://user-images.githubusercontent.com/38686456/159127134-01b1021d-de3d-4ce1-8ad0-ba731c5eecd0.png)

### è·¯ç”±æ³¨å†Œ

 é‚£ä¹ˆï¼Œå¯¹åº”å¤„ç†é“¾è·¯handlersæ˜¯å¦‚ä½•æ³¨å†Œåˆ°å¯¹åº”çš„èŠ‚ç‚¹ä¸Šå‘¢ï¼Ÿ

 ç­”æ¡ˆæ˜¯ï¼šæ‰€æœ‰çš„å¶å­èŠ‚ç‚¹éƒ½ä¼šç»´æŠ¤ä»–çš„ä¸€ä»½å¤„ç†å‡½æ•°åˆ‡ç‰‡ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š 
 ![ginå‰ç¼€æ ‘æ’å…¥èŠ‚ç‚¹](https://user-images.githubusercontent.com/38686456/159504701-b95aac73-3443-405b-9989-59d381103e99.png)

ä¹Ÿå°±æ˜¯è¯´æ‰€æœ‰çš„èŠ‚ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶å­èŠ‚ç‚¹ï¼‰éƒ½ä¼šç»´æŠ¤ä»–çš„ä¸€ä»½handlersã€‚

## æŸ¥æ‰¾

æŸ¥æ‰¾è¿™å—æ¯”è¾ƒå¤æ‚ï¼Œä»£ç é£æ ¼ä¹Ÿæ˜¯æ‰¿è¢­äº†æ·»åŠ è·¯ç”±å’Œæ’å…¥è·¯ç”±çš„é£æ ¼ï¼ŒæŸ¥æ‰¾ä¼šä»æ ¹å¼€å§‹å‘ä¸‹éå†ã€‚è¿™è¾¹çœ‹è¿‡ä»£ç çš„åŒå­¦å¾ˆæœ‰å¯èƒ½ä¼šçœ‹åˆ°å…¶æ•°æ®ç»“æ„ä¸­æœ‰ä¸€ä¸ªindiceså­—æ®µï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
type node struct {
   ...
   indices   string
	 ...
}
```

è¿™ä¸ªå…¶å®æ˜¯å­èŠ‚ç‚¹çš„ç¬¬ä¸€ä¸ªå­—æ¯åˆ—è¡¨ã€‚ç»´æŠ¤è¿™ä¸ªæ˜¯ä¸ºäº†åœ¨è®¿é—®å­èŠ‚ç‚¹æ—¶ç›´æ¥é€šè¿‡è¿™ä¸ªå­—æ¯æ¥åˆ¤æ–­æ˜¯å¦è®¿é—®ï¼Œå‡å°‘è®¿é—®æ¬¡æ•°ã€‚è¿™é‡Œå¯èƒ½è¯»è€…ä¼šç–‘é—®ï¼Œé‚£ä¹ˆè·¯ç”±å­—æ¯é‡å¤æ€ä¹ˆåŠï¼Ÿç­”æ¡ˆæ˜¯æ—¢ç„¶é‡å¤ï¼Œé‚£å¿…ç„¶èŠ‚ç‚¹è¿˜å¯ä»¥å†æ‹†åˆ†æˆå­èŠ‚ç‚¹ï½

![ginèŠ‚ç‚¹å¤±é…](https://user-images.githubusercontent.com/38686456/159505198-cfe34139-cd17-49f2-a85d-4be447e7fff7.png)


ä½†æ˜¯ç”±äºé€šé…ç¬¦çš„å­˜åœ¨ï¼Œä¸”é€šé…ç¬¦èŠ‚ç‚¹å¸¸å¸¸ä½äºå­èŠ‚ç‚¹çš„æœ«å°¾ï¼Œæ‰€ä»¥ä¼šå­˜åœ¨éœ€è¦å›æº¯çš„æƒ…å†µï¼Œé‚£ä¹ˆè¿™æ˜¯æ€ä¹ˆè§£å†³çš„å‘¢ï¼Ÿ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![ginèŠ‚ç‚¹é€šé…](https://user-images.githubusercontent.com/38686456/159505344-7c998952-e23b-42de-871d-a97b1aafbfc5.png)


## ä»£ç ç‰‡æ®µè§£æ

 å…¶å®tree.goä¸»è¦çš„å‡½æ•°åªæœ‰ä¸¤ä¸ªï¼š

- addRoute
- insertChild
- getValue

 ä¸‹é¢åˆ†åˆ«ç®€å•è§£æä¸€ä¸‹è¿™ä¸¤ä¸ªæ–¹æ³•ï¼š

### insertChild

```
func (n *node) insertChild(path string, fullPath string, handlers HandlersChain) {
   for {
      // è¿™é‡Œè§£æPathé‡Œæ˜¯å¦æœ‰é€šé…ç¬¦
      wildcard, i, valid := findWildcard(path)
      if i < 0 { // No wildcard found
         break
      }

      // å¦‚æœæ‰¾åˆ°å¹¶ä¸”æ˜¯éæ³•çš„pathåˆ™ç›´æ¥panic
      if !valid {
         panic("only one wildcard per path segment is allowed, has: '" +
            wildcard + "' in path '" + fullPath + "'")
      }

      // å¦‚æœåªæœ‰é€šé…ç¬¦ä¹Ÿä¼španic
      if len(wildcard) < 2 {
         panic("wildcards must be named with a non-empty name in path '" + fullPath + "'")
      }
      // å¦‚æœæ˜¯:ç±»å‹çš„é€šé…ç¬¦
      if wildcard[0] == ':' { // param
         // æ‹†åˆ†æ‰pathï¼Œå°†é€šé…ç¬¦åç¼€æ‹¿å‡º
         if i > 0 {
            // Insert prefix before the current wildcard
            n.path = path[:i]
            path = path[i:]
         }
				 // ç±»å‹æ˜¯Paramçš„èŠ‚ç‚¹
         child := &node{
            nType:    param,
            path:     wildcard,
            fullPath: fullPath,
         }
         n.addChild(child)
         n.wildChild = true
         n = child
         n.priority++

         // å¦‚æœæ­¤æ—¶pathè¿˜æœªå…¨éƒ¨è§£æå®Œæ¯•
         if len(wildcard) < len(path) {
            path = path[len(wildcard):]

            child := &node{
               priority: 1,
               fullPath: fullPath,
            }
            n.addChild(child)
            n = child
            continue
         }

         // è§£æå®Œæ¯•ç›´æ¥å°†handlersæ·»åŠ åˆ°å¯¹åº”å¶å­èŠ‚ç‚¹ä¸­
         n.handlers = handlers
         return
      }

      // å¦‚æœ*ä¸åœ¨æœ€åï¼Œåˆ™æŠ¥é”™
      if i+len(wildcard) != len(path) {
         panic("catch-all routes are only allowed at the end of the path in path '" + fullPath + "'")
      }

      if len(n.path) > 0 && n.path[len(n.path)-1] == '/' {
         pathSeg := strings.SplitN(n.children[0].path, "/", 2)[0]
         panic("catch-all wildcard '" + path +
            "' in new path '" + fullPath +
            "' conflicts with existing path segment '" + pathSeg +
            "' in existing prefix '" + n.path + pathSeg +
            "'")
      }

      // currently fixed width 1 for '/'
      i--
      if path[i] != '/' {
         panic("no / before catch-all in path '" + fullPath + "'")
      }

      n.path = path[:i]

      // First node: catchAll node with empty path
      child := &node{
         wildChild: true,
         nType:     catchAll,
         fullPath:  fullPath,
      }

      n.addChild(child)
      n.indices = string('/')
      n = child
      n.priority++

      // second node: node holding the variable
      child = &node{
         path:     path[i:],
         nType:    catchAll,
         handlers: handlers,
         priority: 1,
         fullPath: fullPath,
      }
      n.children = []*node{child}

      return
   }

   // è¿™é‡Œå¤„ç†æ²¡æœ‰wildcardçš„æƒ…å†µ
   n.path = path
   n.handlers = handlers
   n.fullPath = fullPath
}
```

### addRoute

```
// addRoute adds a node with the given handle to the path.
// Not concurrency-safe!
func (n *node) addRoute(path string, handlers HandlersChain) {
   fullPath := path
   n.priority++

   // ç©ºæ ‘åˆ™ç›´æ¥æ’å…¥
   if len(n.path) == 0 && len(n.children) == 0 {
      n.insertChild(path, fullPath, handlers)
      n.nType = root
      return
   }

   parentFullPathIndex := 0

walk:
   for {
      // è¿™é‡Œå°†æ‹¿åˆ°æ’å…¥çš„pathå’Œè¢«æ’å…¥çš„èŠ‚ç‚¹çš„å…¬å…±å‰ç¼€ä¸‹æ ‡
      i := longestCommonPrefix(path, n.path)

      // è¿™é‡Œæ‹†åˆ†æ—§çš„å‰ç¼€èŠ‚ç‚¹
      if i < len(n.path) {
         ...
      }

      // è¿™é‡Œæ’å…¥pathçš„éå…¬å…±å‰ç¼€èŠ‚ç‚¹
      if i < len(path) {
        ...
      }
   }
}
```

## getValue

```go
func (n *node) getValue(path string, params *Params, skippedNodes *[]skippedNode, unescape bool) (value nodeValue) {
   var globalParamsCount int16

walk: // Outer loop for walking the tree
   for {
     	// å½“å‰çš„èŠ‚ç‚¹çš„è·¯å¾„
      prefix := n.path
     	// å½“å‰è·å–çš„è·¯å¾„é•¿åº¦å¤§äºè¯¥èŠ‚ç‚¹çš„å‰ç¼€é•¿åº¦
      if len(path) > len(prefix) {
         // å¦‚æœè¯¥èŠ‚ç‚¹çš„è·¯å¾„å’Œpathçš„å‰ç¼€ç¬¦åˆ
         if path[:len(prefix)] == prefix {
            // æˆªå–å‰©ä½™çš„è·¯å¾„ä½œä¸ºpath
            path = path[len(prefix):]

            // å…ˆå°è¯•åŒ¹é…æ‰€æœ‰çš„éé€šé…ç¬¦çš„è·¯å¾„
            idxc := path[0]
            for i, c := range []byte(n.indices) {
               if c == idxc {
                  // å¦‚æœæ˜¯é€šé…ç¬¦å­èŠ‚ç‚¹
                  if n.wildChild {
                     // æ€§èƒ½å‹æ‰©å®¹
                     index := len(*skippedNodes)
                     *skippedNodes = (*skippedNodes)[:index+1]
                     // åŠ å…¥è·³è½¬èŠ‚ç‚¹
                     (*skippedNodes)[index] = skippedNode{
                        path: prefix + path,
                        node: &node{
                           path:      n.path,
                           wildChild: n.wildChild,
                           nType:     n.nType,
                           priority:  n.priority,
                           children:  n.children,
                           handlers:  n.handlers,
                           fullPath:  n.fullPath,
                        },
                        paramsCount: globalParamsCount,
                     }
                  }
									// åˆ°å¯¹åº”çš„åŒ¹é…indicesçš„å­èŠ‚ç‚¹å»
                  n = n.children[i]
                  continue walk
               }
            }

            // å¦‚æœè¯¥èŠ‚ç‚¹æ²¡æœ‰é€šé…ç¬¦çš„å­èŠ‚ç‚¹
            if !n.wildChild {
               // å¦‚æœæœ€åå‰©ä½™åŒ¹é…çš„pathä¸æ˜¯/
               // åˆ™éœ€è¦å›æ»šåˆ°ä¸Šä¸€ä¸ªskipNodes
               if path != "/" {
                  for l := len(*skippedNodes); l > 0; {
                     // å°†æœ€åä¸€ä¸ªå…ƒç´ å¼¹å‡º
                     skippedNode := (*skippedNodes)[l-1]
                     *skippedNodes = (*skippedNodes)[:l-1]
                     // å¦‚æœåŒ¹é…åˆ°è¯¥èŠ‚ç‚¹çš„åç¼€ï¼ˆå› ä¸ºåŠ å…¥æ—¶å·²ç»éªŒè¯è¿‡å‰ç¼€ï¼‰
                     if strings.HasSuffix(skippedNode.path, path) {
                        // å›åˆ°é‚£ä¸ªèŠ‚ç‚¹
                        path = skippedNode.path
                        n = skippedNode.node
                        if value.params != nil {
                           *value.params = (*value.params)[:skippedNode.paramsCount]
                        }
                        globalParamsCount = skippedNode.paramsCount
                        continue walk
                     }
                  }
               }

              // å¦‚æœè¿˜æ˜¯è¿›å…¥ len(path)>len(prefix) çš„æƒ…å†µ
              // åˆ™å°è¯•å»æ‰pathå°¾éƒ¨çš„/
               value.tsr = path == "/" && n.handlers != nil
               return
            }

            // è·å–å°¾éƒ¨çš„é€šé…ç¬¦å­èŠ‚ç‚¹
            n = n.children[len(n.children)-1]
            globalParamsCount++

            switch n.nType {
            case param:
               // è·å–ä¸‹ä¸€ä¸ª/çš„ä¸‹æ ‡æˆ–è€…å­—ç¬¦ä¸²çš„å°¾
               end := 0
               for end < len(path) && path[end] != '/' {
                  end++
               }

               // Save param value
               if params != nil && cap(*params) > 0 {
                  if value.params == nil {
                     value.params = params
                  }
                  // æ•ˆç‡å‹æ‰©å®¹
                  i := len(*value.params)
                  *value.params = (*value.params)[:i+1]
                  val := path[:end]
                  // å¦‚æœæ ‡è®°äº†unescapeåˆ™å°†/å‰é¢çš„å…ƒç´ è§£ç 
                  if unescape {
                     if v, err := url.QueryUnescape(val); err == nil {
                        val = v
                     }
                  }
                  // å°†å¯¹åº”çš„é€šé…ç¬¦å‚æ•°åŠ å…¥
                  (*value.params)[i] = Param{
                     Key:   n.path[1:],
                     Value: val,
                  }
               }

               // å¦‚æœæ²¡åˆ°pathçš„æœ€å
               if end < len(path) {
                  // å¦‚æœä¾ç„¶æœ‰childrenåˆ™ç»§ç»­éå†
                  if len(n.children) > 0 {
                     path = path[end:]
                     n = n.children[0]
                     continue walk
                  }

                  // ... but we can't
                  value.tsr = len(path) == end+1
                  return
               }
							 // èµ°åˆ°è¿™ä»£è¡¨å·²ç»åŒ¹é…åˆ°pathï¼Œè¿”å›å€¼çš„handlers
               if value.handlers = n.handlers; value.handlers != nil {
                  value.fullPath = n.fullPath
                  return
               }
               // å¦‚æœè¯¥èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹
               if len(n.children) == 1 {
                  // No handle found. Check if a handle for this path + a
                  // trailing slash exists for TSR recommendation
                  n = n.children[0]
                  value.tsr = (n.path == "/" && n.handlers != nil) || (n.path == "" && n.indices == "/")
               }
               return
						// catchAllé€šé…ç¬¦
            case catchAll:
               // Save param value
               if params != nil {
                  if value.params == nil {
                     value.params = params
                  }
                  // Expand slice within preallocated capacity
                  i := len(*value.params)
                  *value.params = (*value.params)[:i+1]
                  val := path
                  if unescape {
                     if v, err := url.QueryUnescape(path); err == nil {
                        val = v
                     }
                  }
                  (*value.params)[i] = Param{
                     Key:   n.path[2:],
                     Value: val,
                  }
               }

               value.handlers = n.handlers
               value.fullPath = n.fullPath
               return

            default:
               panic("invalid node type")
            }
         }
      }

      if path == prefix {
         // å³ä½¿åŒ¹é…åˆ°äº†ï¼Œä½†æ˜¯å½“å‰çš„pathä¸ä¸º/å¹¶ä¸”è¯¥èŠ‚ç‚¹æ²¡æœ‰å·²æ³¨å†Œçš„å¤„ç†å‡½æ•°é“¾ï¼Œä½†æœ€è¿‘åŒ¹é…åˆ°çš„èŠ‚ç‚¹æœ‰å…¶ä»–å­èŠ‚ç‚¹ï¼Œåˆ™éœ€è¦å›æ»šåˆ°ä¸Šæ¬¡è·³è¿‡çš„èŠ‚ç‚¹
         if n.handlers == nil && path != "/" {
            for l := len(*skippedNodes); l > 0; {
               skippedNode := (*skippedNodes)[l-1]
               *skippedNodes = (*skippedNodes)[:l-1]
               if strings.HasSuffix(skippedNode.path, path) {
                  path = skippedNode.path
                  n = skippedNode.node
                  if value.params != nil {
                     *value.params = (*value.params)[:skippedNode.paramsCount]
                  }
                  globalParamsCount = skippedNode.paramsCount
                  continue walk
               }
            }
            // n = latestNode.children[len(latestNode.children)-1]
         }
         // We should have reached the node containing the handle.
         // Check if this node has a handle registered.
         if value.handlers = n.handlers; value.handlers != nil {
            value.fullPath = n.fullPath
            return
         }

         // If there is no handle for this route, but this route has a
         // wildcard child, there must be a handle for this path with an
         // additional trailing slash
         if path == "/" && n.wildChild && n.nType != root {
            value.tsr = true
            return
         }

         // No handle found. Check if a handle for this path + a
         // trailing slash exists for trailing slash recommendation
         for i, c := range []byte(n.indices) {
            if c == '/' {
               n = n.children[i]
               value.tsr = (len(n.path) == 1 && n.handlers != nil) ||
                  (n.nType == catchAll && n.children[0].handlers != nil)
               return
            }
         }

         return
      }

      // Nothing found. We can recommend to redirect to the same URL with an
      // extra trailing slash if a leaf exists for that path
      value.tsr = path == "/" ||
         (len(prefix) == len(path)+1 && prefix[len(path)] == '/' &&
            path == prefix[:len(prefix)-1] && n.handlers != nil)

      // roll back to last valid skippedNode
      if !value.tsr && path != "/" {
         for l := len(*skippedNodes); l > 0; {
            skippedNode := (*skippedNodes)[l-1]
            *skippedNodes = (*skippedNodes)[:l-1]
            if strings.HasSuffix(skippedNode.path, path) {
               path = skippedNode.path
               n = skippedNode.node
               if value.params != nil {
                  *value.params = (*value.params)[:skippedNode.paramsCount]
               }
               globalParamsCount = skippedNode.paramsCount
               continue walk
            }
         }
      }

      return
   }
}
```

 æ€»ä½“æ¥è¯´ï¼Œtreeä»£ç ç”±äºé€šé…ç¬¦çš„åŸå› ï¼Œå¢åŠ äº†ä»£ç çš„å¤æ‚åº¦ï¼Œå…¶ä¸­ä¹Ÿæœ‰å¾ˆå¤šè¢«æŠ±æ€¨çš„ç‚¹ï¼Œå¯ä»¥åœ¨Ginçš„issueä¸­æ‰¾åˆ°ï¼Œå¦‚[gin-gonic/gin#2663](https://github.com/gin-gonic/gin/pull/2663) æœ‰å…´è¶£çš„å¯ä»¥å»ç ”ç©¶ä¸€ä¸‹ï½



