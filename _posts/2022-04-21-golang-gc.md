# 浅谈Golang GC

​	Golang作为比较热门的一个编程语言，或者说高级语言，很重要的特性之一是他的垃圾收集。垃圾收集回收掉不需要的内存占用，使我们的程序变得更轻量。

​	谈到GC，首先我们需要简单的理解一下程序执行的两个重要概念：堆和栈。这里的堆不是数据结构的**堆**，两者没有必然联系。**栈**也就是LIFO的数据结构。在Go中，每个协程都拥有自己的栈，而堆则是程序中所有协程所共享的。对于栈而言，在协程执行完毕后，它的数据将被释放。而对于堆来说，它所存储的对象仅会在GC时被清理掉。

​	对于堆存储的数据而言，它存储了Go编译器不知道何时能回收掉的数据。这点和栈不同，栈的数据我们知道最先被回收的是最后分配的数据。当我们的程序中一些方法分配了一个容量较大的切片（slice）或者返回指针时，有可能会产生内存逃逸（*即本应该在栈上分配的数据逃逸到了堆上*）。我们可以通过`go build main -gcflags '-m -l'`来看是否存在内存逃逸的情况。此时，我们可以思考一个问题：为什么上面说的两种情况会产生逃逸？返回指针很好理解，因为现在程序无法确定这个指针指向的数据什么时候被回收。那么对于大切片呢？实际上是由于栈是大小是一定的，所以在Goroutine需要内存时会从P（process）中获取内存。
